---
title:      "OpenGL Notebook #1"
date:       2020-10-17 10:00:00 +0700
categories: programming graphics opengl
---
## Prefacing piece

_Basically just a record and a distillation of stuff from_ [here](learnopengl.com). _Also OpenGL is mostly obsolete now and so this is largely educational, for me._

As in the resource used, OpenGL 3.3 is the version in use here. This also means this is based on GLFW and GLAD libraries.

## Drawing

_This section hereon corresponds to_ [this page](https://learnopengl.com/Getting-started/Hello-Triangle)

OpenGL is a 3D graphics library so all coordinates used are correspondingly in 3D (x, y, z coordinates). Also, OpenGL uses normalized device graphics, meaning the only coordinates drawn are between -1.0 and 1.0. So we can have a set of vertex data like this:

```c++
float vertices[] = {
    -0.5f, -0.5f, 0f,
    0.5f, -0.5f, 0f,
    0f, 0.5f, 0f
};
```

This needs to be sent to be stored in the GPU memory, which we do so using __vertex buffer objects__ (VBO) to allow sending as much vertex data at once as possible (sending stuff to GPU memory is slow).

```c++
unsigned int VBO;           // the ID for the buffer
glGenBuffers(1, &VBO);      // create the buffer assigned to that ID

// bind the buffer to be used to the appropriate target GL_ARRAY_BUFFER
glBindBuffer(GL_ARRAY_BUFFER, VBO);

// copy vertex data onto the buffer's memory
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

It should be noted that multiple buffers can be bound at once, only if they are of different types, which in this case is a `GL_ARRAY_BUFFER`.  
`glBufferData` is a function used to copy user-defined data to the bound buffers, so the first argument is used to specify which buffer to copy to. The second and third arguments are related to the data we want to send.  
The fourth argument has 3 forms:

* `GL_STATIC_DRAW`: the data doesn't change and used many times by the GPU
* `GL_STREAM_DRAW`: the data doesn't change and used a few times at most
* `GL_DYNAMIC_DRAW`: the data is set often and used many times

## Shading

OpenGL requires the minimum of a vertex shader and a fragment shader to be made

<img src="https://learnopengl.com/img/getting-started/pipeline.png">

A __vertex shader__ converts the location data into some other location data to draw the vertices. Its input is one vertex at a time; it is also where the vertex data can be processed.
A __fragment shader__ determines the color of the pixels. It can calculate the final color to be shown based on the data in the 3D scene, such as lights and shadows.

In between those shaders, more processing happens. The vertices are assembled into primitive shapes (here, a triangle). The _geometry shader_ generates new primitives based on the initial vertices and also its own emitted vertices.
This data is then converted into pixels, called _rasterization_, to create the fragments for the fragment shader. After the fragment shader, the final stage performs calculations based on the depth to determine which pixels shouldn't be colored, as well as checking the _alpha levels_(opacity) and _blending_ colors correspondingly.

### Vertex Shaders

Shaders in OpenGL are written in GLSL. A very basic vertex shader looks like this:

```glsl
#version 330 core
layout (location = 0) in vec3 pos;

void main()
{
    gl_Position = vec4(pos.x, pos.y, pos.z, 1.0);
}
```

It begins with the version number, where the GLSL version corresponds with the OpenGL version.
The next line indicates the input the shader takes, in this case a 3D vector called `pos` from `location = 0`, corresponding to the first argument to `glVertexAttribPointer` (which comes later).  
Meanwhile, `gl_Position` is the vector to be used as the output of the vertex shader.

The shader then has to be compiled and assigned a shader ID, specified to be `GL_VERTEX_SHADER`:

```c++
unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
// here we assume vertexShaderSource is a character string containing the shader code
// it can be loaded from a file or written as a string in C++
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);

int success;
char buf[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);

if (!success) {
    glGetShaderInfoLog(vertexShader, 512, NULL, buf);
    std::cout << "ERROR: SHADER COMPILATION FAILED: VERTEX\n" << buf << std::endl;
}
```

Note that the second argument in `glShaderSource` specifies the number of strings (only 1 here).
Also note that we should check if the shader compilation succeeded, using `glGetShaderiv` and printing any errors obtained by `glGetShaderInfoLog`.

### Fragment Shader

As for the fragment shader, a very basic one follows a structure similar to a vertex shader

```glsl
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(0.5f, 1.0f, 0.2f, 1.0f);
}
```

Here, note that there is a size 4 vector output on the second line called `FragColor`. This fragment shader does the basic task of setting primitives to a solid color with an alpha value (RGBA values respectively, with alpha 1.0 being completely opaque).

Also similarly, we assign the shader to an ID and compile it:

```c++
unsigned int fragShader;
fragShader = glCreateShader(GL_FRAGMENT_SHADER);
// also assuming fragShaderSource contains the shader source code
glShaderSource(fragShader, 1, &fragShaderSource, NULL);
glCompileShader(fragShader);

int success;
char buf[512];
glGetShaderiv(fragShader, GL_COMPILE_STATUS, &success);

if (!success) {
    glGetShaderInfoLog(fragShader, 512, NULL, buf);
    std::cout << "ERROR: SHADER COMPILATION FAILED: FRAGMENT\n" << buf << std::endl;
}
```

Note the use of `GL_FRAGMENT_SHADER` as the type when creating the shader and assigning the ID.

### Shader Program

With both the vertex and fragment shaders created, we link them to a shader program. When we make calls to render the scene, the shaders in the active shader program will be the ones that are used.

```c++
// create the shader program and get its ID
unsigned int shaderProgram;
shaderProgram = glCreateProgram();

// link both shaders created
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragShader);
glLinkProgram(shaderProgram);

// also check for linking errors!
int success;
char buf[512];
glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if(!success) {
    glGetProgramInfoLog(shaderProgram, 512, NULL, buf);
    std::cout << "ERROR: PROGRAM LINKING FAILED\n" << buf << std::endl;
}

// then set the shader program to active
glUseProgram(shaderProgram);

// delete shader objects (no needed anymore)
glDeleteShader(vertexShader);
glDeleteShader(fragShader);
```
